# Reference: https://www.youtube.com/watch?v=CD4qAhfFuLo&t=1734s
# Reference: https://pastebin.com/embed_js/jB6k06hG

import random
import pygame
from square import square
from functions import *

# ------------------------------------------------- Code setting up the basics of the snake game
class snake(object):
    frame = []
    rotations = {}

    def __init__(self, tone, pos):
        self.tone = tone
        self.top = square(pos)
        self.frame.append(self.top)
        self.xasis = 0
        self.yasis = 1

        self.barriers = []
        self.barriers.append(self.top)
        self.result = 0

    def motionAuto(self, pointer):  # use this motion method when directions are generated by successor method

        if pointer == "LEFT":
            self.xasis = -1
            self.yasis = 0
            self.rotations[self.top.pos[:]] = [self.xasis, self.yasis]

        elif pointer == "RIGHT":
            self.xasis = 1
            self.yasis = 0
            self.rotations[self.top.pos[:]] = [self.xasis, self.yasis]

        elif pointer == "UP":
            self.xasis = 0
            self.yasis = -1
            self.rotations[self.top.pos[:]] = [self.xasis, self.yasis]

        elif pointer == "DOWN":
            self.xasis = 0
            self.yasis = 1
            self.rotations[self.top.pos[:]] = [self.xasis, self.yasis]

        for i, c in enumerate(self.frame):
            p = c.pos[:]
            if p in self.rotations:
                turn = self.rotations[p]
                c.motion(turn[0], turn[1])
                if i == len(self.frame) - 1:
                    self.rotations.pop(p)
            else:
                if c.xasis == -1 and c.pos[0] <= 0:
                    c.pos = (c.chain - 1, c.pos[1])
                elif c.xasis == 1 and c.pos[0] >= c.chain - 1:
                    c.pos = (0, c.pos[1])
                elif c.yasis == 1 and c.pos[1] >= c.chain - 1:
                    c.pos = (c.pos[0], 0)
                elif c.yasis == -1 and c.pos[1] <= 0:
                    c.pos = (c.pos[0], c.chain - 1)
                else:
                    c.motion(c.xasis, c.yasis)

    def reset(self, pos):
        self.top = square(pos)
        self.frame = []
        self.frame.append(self.top)
        self.rotations = {}
        self.xasis = 0
        self.yasis = 1

        self.barriers = self.frame
        self.result = 0

    def addsquare(self):
        tail = self.frame[-1]
        dx, dy = tail.xasis, tail.yasis

        if dx == 1 and dy == 0:
            self.frame.append(square((tail.pos[0] - 1, tail.pos[1])))
            self.barriers = self.frame
        elif dx == -1 and dy == 0:
            self.frame.append(square((tail.pos[0] + 1, tail.pos[1])))
            self.barriers = self.frame
        elif dx == 0 and dy == 1:
            self.frame.append(square((tail.pos[0], tail.pos[1] - 1)))
            self.barriers = self.frame
        elif dx == 0 and dy == -1:
            self.frame.append(square((tail.pos[0], tail.pos[1] + 1)))
            self.barriers = self.frame

        global everyfence
        everyfence = self.frame

        self.frame[-1].xasis = dx
        self.frame[-1].yasis = dy

    def draw(self, side):
        for i, c in enumerate(self.frame):
            if i == 0:
                c.draw(side, True)
            else:
                c.draw(side)

    def endCondition(self, actualSpot):
        if actualSpot == interim_meal.pos:
            return True
        else:
            return False

    def beginCondition(self):
        return self.top.pos

    def comeIntoReplacement(self, actualSpot):  # more like surrounding grid locales

        fee = 0
        barrierSpot = []
        for x, barrier in enumerate(self.barriers):
            barrierSpot.append(barrier.pos)
        substitute = []  # tuple of states, steps, fee (grid pos, direction to get there, fee to get there)
        x, y = actualSpot
        all_motions = [-1, 1]  # x or y can either stay, increase or decrease locale by 1

        # look at substitute for y axis
        for motionsX in all_motions:
            upcomingX = x + motionsX  # x will motion, y will stay the same
            upcomingY = y
            if upcomingX < 0 or upcomingX > 19:  # make sure we don't go out of bounds
                continue
            upcomingSpot = upcomingX, upcomingY
            if upcomingSpot not in barrierSpot:
                if upcomingSpot != actualSpot:
                    if upcomingSpot not in substitute:
                        dir_X = ""
                        if motionsX == 1:
                            dir_X = "RIGHT"
                            fee = (euclideanDist(actualSpot, interim_meal.pos) / 2) # prioritize left and right steps
                        elif motionsX == -1:
                            dir_X = "LEFT"
                            fee = (euclideanDist(actualSpot, interim_meal.pos) / 2)
                        substitute.append((upcomingSpot, dir_X, fee))

        # look at substitute for y axis
        for motions in all_motions:
            upcomingX = x
            upcomingY = y + motions  # y will motion, x will stay the same
            if upcomingY < 0 or upcomingY > 19:  # make sure we don't go out of bounds
                continue
            upcomingSpot = upcomingX, upcomingY
            if upcomingSpot not in barrierSpot:
                if upcomingSpot != actualSpot:
                    if upcomingSpot not in substitute:
                        directionY = ""
                        if motions == 1:
                            directionY = "DOWN"
                            fee = euclideanDist(actualSpot, interim_meal.pos)
                        elif motions == -1:
                            directionY = "UP"
                            fee = euclideanDist(actualSpot, interim_meal.pos)
                        substitute.append((upcomingSpot, directionY, fee))

        return substitute


def newWindow(side, s):
    global chain, diameter, munch
    side.fill((0, 0, 0))
    s.draw(side)
    munch.draw(side)
    create_grid(diameter, chain, side)
    pygame.display.update()
    # print("yum:", meal.pos)

# global meal
interim_meal = []
beginState = 0


# ------------------------------------------------- End of code setting up the basics of the snake game


# --------------------------------------------------------------------- Running the game normally


# --------------------------------------------------------------------- End of running the game normally


# --------------------------------------------------------------------- End of feeding snake game hardcoded directions

# DEFINE CONSTANTS

FIRST_POSITION = (0, 0)
MEAL_POSITION = []
def mealposition():
    global MEAL_POSITION
    MEAL_POSITION= []
    for j in range(0, 399):  # 400 grid locales, i.e. max num of meal locales can be 400
        meal_xasis = random.randrange(19)
        meal_yasis = random.randrange(19)
        meal = meal_xasis, meal_yasis
        MEAL_POSITION.append(meal)

opterarions_list = [[], [], [], []]
final_list = [0, 0, 0, 0]

# --------------------------------------------------------------------- UCS

# s: snake object
# i : iterator to keep track of where meal will be
# slow_moving: True go slow_moving False go fast
def USC_Searching(s, i, slow_moving):
    from util import Queue
    global diameter, chain, munch, interim_meal, beginState, meal

    def excecuteOperations(steps, slow_moving):
        # perform steps in the game window so we can see the results
        for step in steps:
            if slow_moving:
                pygame.time.delay(50)
                clock.tick(10)
            s.motionAuto(step)
            newWindow(complete, s)

    diameter = 500
    chain = 20
    complete = pygame.display.set_mode((diameter, diameter))
    beginState = FIRST_POSITION
    munch = square(MEAL_POSITION[i], tone=(0, 255, 0))
    interim_meal = munch
    clock = pygame.time.Clock()

    from util import PriorityQueue
    uscpq = PriorityQueue()  # fringe
    visited = set()
    uscpq.push((s.beginCondition(), [], 0), 0)

    while 1:
        if uscpq.isEmpty():
            break

        current, directions, fees = uscpq.pop()  # add fees for ucs
        if current not in visited:
            visited.add(current)
            if s.endCondition(current):
                s.result += 1
                s.addsquare()
                excecuteOperations(directions, slow_moving)
                opterarions_list[3].append(len(directions))
                final_list[3] = len(s.frame)
            for children_node, direction, fee in s.comeIntoReplacement(current):
                if children_node not in uscpq.heap:
                    if children_node in visited:  # make sure child is not in visited so we don't go backwards
                        continue
                    uscpq.push((children_node, directions + [direction], fees + fee), fees + fee)

def showGame():
    mealposition()
    gameSnake = snake((255, 0, 0), FIRST_POSITION)
    gmoving = True
    for i in range(0, 255):
        USC_Searching(gameSnake, i, gmoving)
    gameSnake.reset(FIRST_POSITION)

showGame()
